
<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>SQL Avancé</title>

        <link href="/do-it/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
        <link href="/do-it/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

        <link href="/do-it/assets/stylesheets/main.css" rel="stylesheet">
    </head>
    <body>
        <script>
        window.MathJax = {
            tex: {
            inlineMath: [
                [
                '$', '$'
                ],
                [
                '\\(', '\\)'
                ]
            ]
            },
            svg: {
            fontCache: 'global'
            }
        };
        </script>
        <script type="text/javascript" id="MathJax-script" src="/do-it/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

        <header class="border-b-2 border-gray-200 mb-4">
        <div class="max-w-[1000px] mx-auto px-4">
            <div class="min-h-[50px] flex justify-between items-center">
                <a class="mx-2" href="/do-it/">Home</a>
                <div class="flex items-center gap-4 sm:gap-6 ">
                    <a class="" href="/do-it/cs">CS</a>
                    <a class="" href="/do-it/pok">POK</a>
                    <a class="" href="/do-it/mon">MON</a>
                    <a class="" href="/do-it/projets">Projets</a>
                    <a class="hidden sm:block" href="/do-it/promos">Promos</a>
                    <a href="/do-it/search">
                        <svg class="h-5 aspect-square" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path>
                        </svg>
                    </a>
                    <a class="hidden sm:block" href="https://github.com/FrancoisBrucker/do-it" target="_blank">
                        <svg class="h-5 aspect-square" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg>
                    </a>
                </div>
            </div>
        </div>
        </header>

        <main class="max-w-[1000px] mx-auto px-4" data-pagefind-body="">
            
<article class="relative">
<h1 class="mb-1">SQL Avancé</h1>
<div class="mb-4">
    
        <div class="px-4 flex flex-wrap items-center">
            
                <div class="font-bold">Tags : </div>
            
            <ul class="flex flex-wrap overflow-auto not-prose list-none my-1 mx-0 px-1 gap-1" data-pagefind-meta="Tags">
                
                    <li class="bg-yellow-200 rounded-full px-2" data-pagefind-filter="Tags">MON</li>
                
                    <li class="bg-yellow-200 rounded-full px-2" data-pagefind-filter="Tags">2024-2025</li>
                
                    <li class="bg-yellow-200 rounded-full px-2" data-pagefind-filter="Tags">temps 1</li>
                
                    <li class="bg-yellow-200 rounded-full px-2" data-pagefind-filter="Tags">vert</li>
                
                    <li class="bg-yellow-200 rounded-full px-2" data-pagefind-filter="Tags">avancé</li>
                
                    <li class="bg-yellow-200 rounded-full px-2" data-pagefind-filter="Tags">sql</li>
                

            </ul>
            
            
            <div class="hidden" data-pagefind-meta="Type">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </div>
        </div>
    

    
        <div class="px-4 flex flex-wrap items-center">
            <div class="font-bold">Auteurs : </div>
            <ul class="flex flex-wrap not-prose list-none my-1 mx-0 px-1 gap-1" data-pagefind-meta="Auteurs">
                
                    <li class="bg-blue-200 rounded-full px-2" data-pagefind-filter="Auteurs">Valentin Billa</li>
                
            </ul>
        </div>
    

    
</div>

        <p class="mb-4 text-lg">

                Apprentissage de fonctionnalités avancées SQL

        </p>



    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a href="/do-it/promos/">Promotions</a><span class="px-1">/</span><a href="/do-it/promos/2024-2025/">2024-2025</a><span class="px-1">/</span><a href="/do-it/promos/2024-2025/Billa-Valentin/">Valentin Billa</a><span class="px-1">/</span><a href="/do-it/promos/2024-2025/Billa-Valentin/mon/">MONs Valentin Billa</a><span class="px-1">/</span><a href="/do-it/promos/2024-2025/Billa-Valentin/mon/temps-1.1/">SQL Avancé</a>

</div></div>




<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-pink-500 bg-pink-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-pink-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><strong>Prérequis :</strong></p>
</div><div class="pl-8 mr-8">
<ul>
<li>Vocabulaire de base solide en SQL (colonne, table, query...)</li>
<li>SQL Basique (SELECT, FROM, WHERE...)</li>
</ul>
</div></div>
<h2>Objectifs</h2>
<p>Ayant une attirance particulière pour le back, SQL me fait de l'œil !
C'est pourquoi je souhaite me former à ses fonctions les plus avancées,
à minima pour savoir qu'elles existent le jour où j'en aurais besoin.</p>
<p>Ce MON sera plutôt orienté MySQL (car j'aime bien leur doc) mais je
tenterais de faire des parallèles avec d'autres SGBD (Système de Gestion de Base de Données)
comme SQLite, PostgresSQL</p>
<h2>Optimization en Général</h2>
<h3>SQL</h3>
<p>Une particularité de SQL qu'il est important de garder en tête est qu'il ne s'agit pas réellement d'un langage
de programmation au sens traditionnel, mais plutôt d'un langage déclaratif. Lorsque nous écrivons une requête SQL,
nous ne donnons pas d'instructions détaillées sur la façon d'obtenir les données, mais nous décrivons plutôt
le résultat souhaité. C'est au SGBD de déterminer le meilleur moyen d'obtenir ce résultat.</p>
<p>Pour optimiser les requêtes SQL, il est crucial de comprendre comment le moteur de base de données interprète et exécute
ces requêtes. Une des méthodes essentielles pour obtenir y arriver est l'utilisation de la commande <code>EXPLAIN</code>.</p>
<h3>La commande <code>EXPLAIN</code></h3>
<p>La commande <code>EXPLAIN</code> permet de voir comment le SGBD interprète une requête SQL. Elle fournit des informations
détaillées sur le plan d'exécution d'une requête, ce qui peut aider à identifier les parties de la requête qui
pourraient être optimisées pour améliorer les performances.</p>
<p>Pour utiliser <code>EXPLAIN</code>, il suffit de la précéder à une requête SQL :</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> age <span class="token operator">></span> <span class="token number">25</span><span class="token punctuation">;</span></code></pre>
<p>Le résultat de <code>EXPLAIN</code> comprend plusieurs colonnes importantes, notamment :</p>
<ul>
<li><strong>id</strong> : l'identifiant unique de l'étape de requête.</li>
<li><strong>select_type</strong> : le type de requête SQL principale.</li>
<li><strong>table</strong> : la table à laquelle la requête accède.</li>
<li><strong>possible_keys</strong> : les index qui peuvent être utilisés pour accélérer la requête.</li>
<li><strong>key</strong> : l'index effectivement utilisé.</li>
<li><strong>rows</strong> : le nombre estimé de lignes que le SGBD doit parcourir pour satisfaire cette étape de la requête.</li>
<li><strong>Extra</strong> : des informations supplémentaires sur l'exécution de la requête.</li>
</ul>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>La commande <code>EXPLAIN</code> renvoie un résultat honnêtement difficile à aborder les premières fois.
Avec le temps, on comprend de mieux en mieux les particularités à prendre en compte eg. les différents types de
<strong>select_type</strong> et en l'occurrence ceux qui sont symptomatiques d'une query qui va être lente.</p>
</div></div>
<p>Par exemple, pour la requête précédente, le résultat de <code>EXPLAIN</code> pourrait ressembler à ceci :</p>
<pre class="language-text"><code class="language-text">> EXPLAIN EXPLAIN SELECT * FROM users WHERE age > 25;
+----+-------------+-------+---------------+---------+---------+------+---------+-------------+
| id | select_type | table | possible_keys | key     | key_len | ref  | rows    | Extra       |
+----+-------------+-------+---------------+---------+---------+------+---------+-------------+
|  1 | SIMPLE      | users | NULL          | NULL    | NULL    | NULL | 1000000 | Using where |
+----+-------------+-------+---------------+---------+---------+------+---------+-------------+</code></pre>
<p>Dans cet exemple, on voit que la table <code>users</code> est analysée sans utiliser d'index (NULL), et que la requête estime
devoir parcourir un million de lignes pour trouver les résultats. Cette estimation n'est pas anodyne, le SGBD fait
des statistiques au fur et à mesure des requêtes faites en bases de données et s'en sert pour mieux adapter le plan
d'exécution, il est important que ces estimations ne soient pas trop loin du compte.</p>
<p>Une autre utilité d'<code>EXPLAIN</code> est de déterminer si deux requêtes SQL sont strictement équivalentes lors de leur exécution.
Ça peut être utile quand on essaie de réécrire une requête pour qu'elle soit plus lisible.</p>
<p>Par exemple</p>
<pre class="language-sql"><code class="language-sql"><span class="token comment">-- requête 1 (on parlera du mot clés WITH en dessous)</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">WITH</span> filtered_users <span class="token keyword">AS</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> age <span class="token operator">></span> <span class="token number">25</span>
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> f<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> orders<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">FROM</span> filtered_users f
<span class="token keyword">JOIN</span> orders <span class="token keyword">ON</span> f<span class="token punctuation">.</span>user_id <span class="token operator">=</span> orders<span class="token punctuation">.</span>user_id<span class="token punctuation">;</span>

<span class="token comment">-- requête 2</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> u<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> o<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">FROM</span> users u<span class="token punctuation">,</span> orders o
<span class="token keyword">WHERE</span> u<span class="token punctuation">.</span>age <span class="token operator">></span> <span class="token number">25</span> <span class="token operator">AND</span> u<span class="token punctuation">.</span>user_id <span class="token operator">=</span> o<span class="token punctuation">.</span>user_id<span class="token punctuation">;</span></code></pre>
<p>Les plans d'exécution pour ces deux requêtes sont identiques, car elles accomplissent essentiellement la même tâche.</p>
<pre class="language-text"><code class="language-text">+----+-------------+-------+---------------+---------+---------+------+---------+--------------------------------+
| id | select_type | table | possible_keys | key     | key_len | ref  | rows    | Extra                          |
+----+-------------+-------+---------------+---------+---------+------+---------+--------------------------------+
|  1 | SIMPLE      | users | NULL          | NULL    | NULL    | NULL | 1000000 | Using where; Using join buffer |
|  1 | SIMPLE      | orders| NULL          | NULL    | NULL    | NULL | 1000000 |                                |
+----+-------------+-------+---------------+---------+---------+------+---------+--------------------------------+</code></pre>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Attention néanmoins, il faut toujours garder en tête que même si deux requêtes font la même chose,
elles peuvent mener à un plan d'exécution différent. En effet, le SQBD est libre d'interpréter le SQL
comme il le souhaite la seule garantie est qu'il renverra les résultats qu'on lui a demandés.</p>
</div></div>
<h3>La commande <code>ANALYZE</code></h3>
<p>La commande <code>ANALYZE</code> est utilisée pour analyser et stocker les informations clé pour une table.
Elle permet d'explicitement demander au SGBD de collecter des statistiques sur la distribution des données dans une table.
Comme on l'a vu dans la partie <code>EXPLAIN</code> elle peut être très utile pour corriger des erreurs d'estimations.</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">ANALYZE</span> <span class="token keyword">TABLE</span> users<span class="token punctuation">;</span></code></pre>
<h3>La commande <code>OPTIMIZE</code></h3>
<p>La commande <code>OPTIMIZE</code> est utilisée pour optimiser les tables dans des bases de données comme MySQL. Elle est utile pour
récupérer l'espace inutilisé et pour améliorer les performances des requêtes. Après de nombreuses opérations
d'insertion, de mise à jour et de suppression, les tables peuvent devenir fragmentées. Utiliser la commande <code>OPTIMIZE</code>
aide à défragmenter les tables et à réorganiser les données sur le disque pour une performance optimale.</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> users<span class="token punctuation">;</span></code></pre>
<p>Lorsque la commande est exécutée, le SGBD effectue les étapes suivantes:</p>
<ul>
<li>Défragmente la table et libère l'espace inutilisé.</li>
<li>Réarrange les tables et les index.</li>
<li>Actualise les statistiques des tables.</li>
</ul>
<p><code>OPTIMIZE</code> tout comme <code>ANALYZE</code> est une opération lourde qui doit être utilisée à bon escient, ie. par avant chaque requête,
ce serait contre productif.</p>
<h2>Indexes</h2>
<p>Les <strong>indexes</strong> sont des structures de données associées aux tables d'une base de données. Ils permettent d'accélérer
considérablement les opérations de recherche en fournissant un accès rapide aux lignes de la table en fonction des
valeurs des colonnes indexées.</p>
<p>Ils permettent des optimisations de deux façons :</p>
<ul>
<li><strong>Amélioration des performances des requêtes</strong> : Les indexes réduisent le temps de recherche des données. Par exemple,
une recherche d'une ligne spécifique basée sur une colonne indexée sera beaucoup plus rapide qu'une recherche sans
index.</li>
<li><strong>Optimisation des tris et des jointures</strong> : Les indexes peuvent être utilisés pour accélérer les opérations de tri (
ORDER BY) et de jointure (JOIN), car les données sont souvent organisées de manière pré-optimisée.</li>
</ul>
<p>Cependant, les indexes ont un <strong>coût spatial</strong> non négligeable. En effet, ils occupent de l'espace disque supplémentaire
qui peut devenir significatif, surtout si plusieurs colonnes d'une table sont indexées. Les indexes doivent également
être mis à jour chaque fois que les données de la table sont modifiées (insertions, suppressions, mises à jour), ce qui
peut ajouter un surcoût en termes de temps de traitement.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Une bonne pratique est de prioriser l'indexage des colones que l'on utilise beaucoup pour faire des tris ou filtres.</p>
</div></div>
<p>Voici un exemple de création d'index pour la colonne <code>age</code> de la table <code>users</code> :</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_users_age <span class="token keyword">ON</span> users <span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Ce code crée un index sur la colonne <code>age</code> de la table <code>users</code>, ce qui peut améliorer la performance des requêtes qui
filtrent ou trient par la colonne <code>age</code>.</p>
<p>L'impact de cet index peut être observé dans le tableau <code>EXPLAIN</code> précédent :</p>
<pre class="language-text"><code class="language-text">> EXPLAIN EXPLAIN SELECT * FROM users WHERE age > 25;
+----+-------------+-------+---------------+---------------+---------+------+---------+--------------------------+
| id | select_type | table | possible_keys | key           | key_len | ref  | rows    | Extra                    |
+----+-------------+-------+---------------+---------------+---------+------+---------+--------------------------+
|  1 | SIMPLE      | users | idx_users_age | idx_users_age | 5       | NULL | 1000000 | Using where; Using index |
+----+-------------+-------+---------------+---------------+---------+------+---------+--------------------------+</code></pre>
<p>Avec l'index <code>idx_users_age</code>, le SGBD (Système de Gestion de Base de Données) peut utiliser cet index pour optimiser
l'accès aux lignes de la table <code>users</code> en fonction de la colonne <code>age</code>, réduisant ainsi le temps de traitement des
requêtes.</p>
<h3>Indexes spatiaux</h3>
<p>Il existe aussi des <strong>indexes spatiaux</strong> (comme les R-trees dans PostGIS pour PostgreSQL) qui sont très utiles pour les
opérations géospatiales impliquant des centaines de millions de points. J'ai utilisé ces indexes dans un projet
PostGIS pour optimiser les requêtes géospatiales, telles que les recherches de proximité et les calculs d'intersection,
qui seraient autrement très coûteux en termes de temps de traitement (surtout avec des dizaines de millions de coordonnées).</p>
<p>Voici un exemple d'utilisation d'un index spatial pour optimiser une requête :</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_spatial_users_location <span class="token keyword">ON</span> users <span class="token keyword">USING</span> GIST <span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users
<span class="token keyword">WHERE</span> ST_DWithin<span class="token punctuation">(</span>location<span class="token punctuation">,</span> ST_MakePoint<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">73.9866</span><span class="token punctuation">,</span> <span class="token number">40.7306</span><span class="token punctuation">)</span>::geography<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Créer un index spatial sur la colonne <code>location</code> permet au SGBD de traiter beaucoup plus rapidement les requêtes
impliquant des opérations géospatiales complexes.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Pour la suite du MON, j'ai exploré différents concepts sans forcément chercher à faire des liens entre eux.
Ce sont des mots clés, options, possibilités utiles individuellement.</p>
</div></div>
<h2>Vues</h2>
<p>Les <strong>vues</strong> (mot clé <code>VIEW</code>) sont des objets de la base de données qui permettent de sauvegarder des requêtes
sous la forme d'une table virtuelle. Elles permettent de simplifier l'écriture de requête, souvent  en encapsulant
des jointures complexes. Voici un exemple de création de vue :</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> users_over_25 <span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> users
<span class="token keyword">WHERE</span> age <span class="token operator">></span> <span class="token number">25</span><span class="token punctuation">;</span></code></pre>
<p>Cette vue <code>users_over_25</code> peut ensuite être utilisée comme une table normale :</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> users_over_25<span class="token punctuation">;</span></code></pre>
<p>Les vues peuvent également être mises à jour si elles satisfont certaines conditions, notamment si elles référencent une
seule table.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Il ne faut cependant pas se faire avoir, les jointures complexes ou conditions définies dans la vue ne sont <strong>pas</strong>
calculées en avance, mais plutôt intégrées lors de l'exécution de la requête. De ce fait, l'utilisation de vue fait
gagner en lisibilité sans gain de performance.</p>
</div></div>
<h3>Les mots clés <code>WITH</code></h3>
<p>Le mot clé <code>WITH</code> est utilisé pour introduire une clause <code>Common Table Expressions</code> (CTE) qui permet de définir des
tables temporaires dont la portée est limitée à la requête dans laquelle elles sont définies. Cela peut entraîner une
meilleure lisibilité et réutilisation des requêtes complexes. Voici un exemple de CTE :</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">WITH</span> UsersOver25 <span class="token keyword">AS</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> <span class="token operator">*</span>
    <span class="token keyword">FROM</span> users
    <span class="token keyword">WHERE</span> age <span class="token operator">></span> <span class="token number">25</span>
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> UsersOver25
<span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">'A%'</span><span class="token punctuation">;</span></code></pre>
<p>Dans cet exemple, la CTE <code>UsersOver25</code> est définie et utilisée dans la même requête pour filtrer les utilisateurs dont
le nom commence par 'A'.</p>
<p>Les CTE peuvent également être récursives. Voici un exemple de CTE récursive :</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">WITH</span> RECURSIVE EmployeeHierarchy <span class="token keyword">AS</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span> manager_id<span class="token punctuation">,</span> name
    <span class="token keyword">FROM</span> employees
    <span class="token keyword">WHERE</span> manager_id <span class="token operator">IS</span> <span class="token boolean">NULL</span>
<span class="token keyword">UNION</span> <span class="token keyword">ALL</span>
    <span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>employee_id<span class="token punctuation">,</span> e<span class="token punctuation">.</span>manager_id<span class="token punctuation">,</span> e<span class="token punctuation">.</span>name
    <span class="token keyword">FROM</span> employees e
    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> EmployeeHierarchy eh <span class="token keyword">ON</span> e<span class="token punctuation">.</span>manager_id <span class="token operator">=</span> eh<span class="token punctuation">.</span>employee_id
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> EmployeeHierarchy<span class="token punctuation">;</span></code></pre>
<p>Ce code permet de créer une hiérarchie de l'organisation des employés où chaque employé est relié à son manager.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p>La feature est intéressante, mais pas facile à comprendre, la meilleure
explication que j'ai trouvée pour l'instant est dans une <a href="https://stackoverflow.com/a/18660789">réponse StackOverflow</a>.</p>
</div></div>

<h2>Procédures stockées</h2>
<p>Les <strong>procédures stockées</strong> sont des sous-programmes stockés dans la base de données. Elles permettent d'exécuter des
suites d'instructions de manière réutilisable et optimisée. Cette fonctionnalité n'est pas standardisée c'est pourquoi
nous allons devoir faire une disjonction de cas en fonction du SGBD.</p>
<h3>SQLite</h3>
<p>SQLite ne supporte pas directement les procédures stockées. Il est plutôt encouragé de créer lesdites procédures
directement dans le programme appellant en créant des scripts.</p>
<h3>MySQL</h3>
<p>La syntaxe pour créer une procédure stockée en MySQL est la suivante :</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">DELIMITER</span> $$

<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> AjouterUtilisateur<span class="token punctuation">(</span><span class="token operator">IN</span> nom <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">IN</span> age <span class="token keyword">INT</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> users <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>nom<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">END</span>$$

<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></code></pre>
<p>Vous pouvez appeler cette procédure comme suit :</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">CALL</span> AjouterUtilisateur<span class="token punctuation">(</span><span class="token string">'John Doe'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Les procédures stockées peuvent accepter des paramètres d'entrée (<code>IN</code>), de sortie (<code>OUT</code>), ou des
paramètres d'entrée/sortie (<code>INOUT</code>).</p>
<h3>PostgreSQL</h3>
<p>Pour créer une procédure stockée en PostgresSQL, on peut utiliser deux syntaxes :</p>
<ol>
<li><code>CREATE FUNCTION</code></li>
</ol>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> AjouterUtilisateur<span class="token punctuation">(</span>nom <span class="token keyword">VARCHAR</span><span class="token punctuation">,</span> age <span class="token keyword">INTEGER</span><span class="token punctuation">)</span>
<span class="token keyword">RETURNS</span> VOID <span class="token keyword">AS</span> $$
<span class="token keyword">BEGIN</span>
    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> users <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>nom<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span>
$$ <span class="token keyword">LANGUAGE</span> plpgsql<span class="token punctuation">;</span></code></pre>
<ol start="2">
<li><code>CREATE PROCEDURE</code> <em>introduite à partir de la version 11</em></li>
</ol>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> AjouterUtilisateur<span class="token punctuation">(</span>nom <span class="token keyword">VARCHAR</span><span class="token punctuation">,</span> age <span class="token keyword">INTEGER</span><span class="token punctuation">)</span>
<span class="token keyword">LANGUAGE</span> <span class="token keyword">SQL</span>
<span class="token keyword">AS</span> $$
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> users <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>nom<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
$$<span class="token punctuation">;</span></code></pre>
<p>Pour appeler cette fonction, on utilise :</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> AjouterUtilisateur<span class="token punctuation">(</span><span class="token string">'Jane Doe'</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Les fonctions peuvent retourner différentes valeurs types (par exemple, <code>VOID</code>, <code>TABLE</code>, etc.)
et prennent en charge un large éventail de langages de programmation via des langages procéduraux comme <code>plpgsql</code>.</p>
<h2>Bibliographie</h2>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<ul>
<li><a href="https://www.w3schools.com/sql/sql_quickref.asp">W3Schools SQL Quickref</a>
<em>documentation plutôt détaillée de tout un tas de fonctionnalités SQL</em></li>
<li><a href="https://www.geeksforgeeks.org">GeeksForGeeks</a>
<em>bon site regroupant tutoriels et explications (pas seulement pour SQL)</em></li>
<li><a href="https://dev.mysql.com/doc/refman/9.0/en/">Doc MySQL 9.0</a>
<em>je la trouve plus facile à naviguer que les deux autres</em></li>
<li><a href="https://www.sqlite.org/docs.html">Doc SQLite</a></li>
<li><a href="https://www.postgresql.org/docs/current/index.html">Doc PostgresSQL 16.4</a></li>
<li><a href="https://www.youtube.com/watch?v=5Pc18ge9ohI">Writing My Own Database From Scratch - Tony Saro</a>
<em>vidéo extrêmement enrichissante sur les détails techniques des SGBD</em></li>
</ul>
</div></div>

<h2>Concepts à approfondir</h2>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.4/en/window-functions-usage.html">Window Functions</a></li>
<li><a href="https://sqlspreads.com/blog/temporal-tables-in-sql-server/">Temporal Tables (SQL Server)</a>
<em>J'en ai entendu parler lors de mon premier stage, le concept a l'air sacrément utile</em></li>
<li><a href="https://dev.mysql.com/doc/refman/8.4/en/fulltext-search.html">FULLTEXT Search</a>
<em>Permet de créer un index sur des données textuelles pour faire de la recherche rapide</em></li>
</ul>


</article>

        </main>


        <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
            <div class="max-w-[1000px] mx-auto px-4">
                <div class="min-h-[50px] flex justify-center items-center">
                    <p class="text-center">
                        <span style="font-family: Consolas, sans-serif;">Do_<span style="color: #4a86e8">It</span></span> : Développent et Organisation en IT
                    </p>
                </div>
            </div>
        </footer>

        <script>
        MathJax
            .startup
            .document
            .getMathItemsWithin(document.body);
        </script>
    </body>
</html>
