
<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <title>MON 2.2 - Langage assembleur</title>

    <link href=/do-it/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css rel="stylesheet">
    <link href=/do-it/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css rel="stylesheet">

    <link href=/do-it/assets/stylesheets/main.css rel="stylesheet">
  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" 
  src=/do-it/assets/node_modules/mathjax/es5/tex-svg-full.js></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/do-it/">Home</a>
          <a class="mx-2" href="/do-it/about">About</a>
        </div>
      </div>
    </header>

    <main class="max-w-[1000px] mx-auto px-4">

      
<article>
  <h1  class="mb-1">MON 2.2 - Langage assembleur</h1>
  <div class="mb-4">
    
      <div class=" px-4 flex items-center">
        
          <div class="font-bold">Tags : </div>
        
        <ul class="flex not-prose list-none my-0 last:after:content-['•'] last:after:px-1 mx-0 px-1">
          
            <li class="before:content-['•'] before:px-1">assembler</li>
          
            <li class="before:content-['•'] before:px-1">reverse engineering</li>
          
            <li class="before:content-['•'] before:px-1">arm</li>
          
            <li class="before:content-['•'] before:px-1">x86</li>
          
        </ul>
      </div>
    

    
      <div class=" px-4 flex items-center">
        
          <div class="font-bold">Auteur : </div>
        
        <ul class="flex not-prose list-none my-0 last:after:content-['•'] last:after:px-1 mx-0 px-1">
          
            <li class="before:content-['•'] before:px-1">Kasimir Romer</li>
          
        </ul>
      </div>
    
  </div>

  

  <!-- Début Résumé -->
<p>Dans ce MON, je vais apprendre les bases du langage d'assemblage ARM et le comparer avec celui de l'architecture x86. Si le temps le permet, j'étudierai le déboguage et la reverse-engineering avec gdb et Ghidra car c'est un bon cas d'utilisation pour appliquer les connaissances de l'assembleur.</p>
<!-- fin résumé -->
<!-- ## Structure de ce MON
1. Introduction
  - What is assembly language?
    - Assembly vs high-level language
  - Use cases of assembly language
    - Super fast execution
    - Embedded systems (memory constraints, ...)
    - Reverse engineering -> most important for me personally
  - Differences of different assembly languages (x86, ARM, ...)
2. Assembly language for ARM
  - why? -> ARM is used in many embedded systems and will be used more and more in the future
  - follow tutorial on https://azeria-labs.com/writing-arm-assembly-part-1/
3. Assembly language for x86
  - not in depth, only show the key differences to ARM assembly
4. Reverse engineering with gdb, radare2 and Ghidra (only if time permits)
  - gdb
  - radare2
  - Ghidra
5. Useful resources
  - Online resources
  - Tools (like online assemblers, ...) -->
<h2>Introduction</h2>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-pink-500 bg-pink-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-pink-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Prerequisites</strong></p>
</div><div class="pl-8 mr-8">
<p>In order to follow this MON (or any tutorial other on assembly programming), you should have basic knowledge of computer architecture and programming. You should at least:</p>
<ul>
<li>Understand the basic concepts of a computer (CPU, memory, input/output, ...)</li>
<li>Being familiar with binary and hexadecimal numbers</li>
<li>Know the basics of at least one high-level programming language like C++ or Java</li>
</ul>
<p>For a deeper understanding of machine language and compilers, see the <a href="../../JBD/Mes_MON/compilateur">MON of Jean-Baptiste</a> (but that's not necessary for understanding this MON)</p>
</div></div>
<h3>What is assembly language?</h3>
<p>Assembly language is a very low-level programming language. It is being translated to machine code (binary code executed by the CPU) by an assembler. Because it is so hardware-near, it is very fast and efficient. However, it is harder to read and write than high-level languages like C++ or Java, that's why it only used in few use cases nowadays.</p>
<h3>Use cases of assembly language</h3>
<p>Assembly language is nowadays mostly used in <strong>embedded systems</strong> like microcontrollers, where the hardware is very limited (in terms of memory and processing power), so the performance of the code is very important. Because assembly language is hardware-near, it is used in cases where hardware-specific functions need to be used. Additionally, assembly language is used in <strong>reverse engineering</strong> to understand how a program works. The code recovered from a program can be disassembled to assembly language and then analyzed.<br>
Besides those use cases, it is great to learn assembly language in order to <strong>understand the architecture of a computer</strong> with its CPU, registers, memory and I/O. It is also useful to understand how a program works in general and how it is executed by the CPU. This permets better software development and debugging, e.g. by knowing potential for optimizing or better securing the software.<br>
Other special use cases are <strong>OS and driver development</strong> because some of the functions in those area can't be implemented in high-level languages. Assembly language is used unknowingly by many programs, because the compiler that compiles high-level languages (C and C++ code) <strong>generates assembly code</strong>.</p>
<h3>Differences of different assembly languages (x86, ARM, ...)</h3>
<p>There is no single &quot;assembly language&quot; because the instruction set of every CPU varies and therefore the language to control those instructions also varies. This means that every CPU has its own assembly language, but as they are very similar, it is possible to learn one assembly language and then learn the others relatively quickly. They share big parts of the syntax, so one can adapt quickly to a new assembly language if he needs to program for a different CPU. Nowadays, mainly two families of CPUs, and thus two families of assembly language, are used: x86 and ARM.</p>
<h4>x86</h4>
<p>The x86 family is used in most <strong>desktop computers</strong>. The CPUs of the x86 family use a <strong>CISC (complex instruction set computer)</strong> architecture. CISC CPUs have a larger, more complex instruction set with many specialized instructions for a variety of tasks. This allows them to perform a wider range of functions, but at the cost of slower execution times and increased complexity in the CPU. Because the instruction set is so complex, it is not easy to learn x86 assembly. The most well-known CPUs of this family are the Intel Core i3, i5 and i7 CPUs and the AMD Ryzen CPUs, so assumingly it is the CPU that is used in the computer you are using to read this MON at the moment.</p>
<h4>ARM</h4>
<p>The instruction set of the ARM CPU family is much simpler because it uses a <strong>RISC (reduced instruction set computer)</strong> architecture. RISC CPUs have a small, fixed instruction set with a limited number of instructions that can be executed quickly. This reduces the complexity of the CPU and allows it to execute instructions more quickly, at the cost of some flexibility. However, some instructions that can be executed in one step on a CISC CPU need multiple steps on a RISC CPU. ARM CPUs are used in most <strong>mobile devices and embedded systems</strong>. The most common CPUs of this family are the Apple A-series CPUs like the A15 Bionic which is used in the iPhone 14 and the Qualcomm Snapdragon CPUs like the Snapdragon 888 which is used in the Samsung Galaxy S21. In many embedded systems, ARM Cortex CPUs are used like the Cortex-M4 which is used in the popular STM32F4 microcontroller. ARM also spreads into the feld where x86 is dominating, e.g. with the Apple M2 chip which is used in the newest MacBook Air and the MacBook Pro and is considered extremely energy-efficient while still being very powerful. This shows that ARM will get even more relevant in the near future and could replace the x86 architecture in many domains.</p>
<h2>Assembly language for ARM</h2>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-pink-500 bg-pink-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-pink-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p>To learn ARM assembly, I used the following sources:</p>
</div><div class="pl-8 mr-8">
<ul>
<li><a href="https://www.youtube.com/watch?v=gfmRrPjnEw4">Assembly Language Programming with ARM – Full Tutorial for Beginners (YouTube)</a></li>
<li><a href="https://azeria-labs.com/writing-arm-assembly-part-1/">azeria-labs.com - Writing ARM assembly</a></li>
<li><a href="https://www.amazon.fr/Modern-Assembly-Language-Programming-Processor/dp/0128036982/">Larry D. Pyeatt: &quot;Modern Assembly Language Programming with the ARM Processor&quot; (book)</a></li>
</ul>
<p>The YouTube tutorial focuses more on showing the different instructions, azeria-labs goes deeper into some of the topics and allows a very good understanding of the basics. In my opinion, the combination of those two sources is great to learn ARM assembly.</p>
</div></div>
<h3>Running ARM assembly code</h3>
<p>To use the ARM assembly language, you need a device containing an ARM (micro)chip where the assembled code is stored and executed. For example, the <em>Raspberry Pi 4 Model B</em>, the current version of the Raspberry Pi computer, uses a Broadcomm BCM2711 SoC (system-on-a-chip) that includes the Cortex A-72 ARM chip as CPU. This means that you can use the ARM assembly language directly on the Raspberry Pi to get a real-world experience and direct hardware integration, e.g. you can blink the onboard LED etc.</p>
<p>If you don't have access to a ARM chip, an emulator can be used. The advantage is that you can inspect the whole memory at every given time, easily understand changes that the program makes to the memory, and that you don't need to flash the device with the new code after every change that is made in the code. You can find an online ARM emulator <a href="https://cpulator.01xz.net/?sys=arm-de1soc">here</a>.</p>
<p>In this MON, I will mainly use the emulator to write and execute the assembly code. Maybe later, I will test it also with the Raspberry Pi 4 that is laying around in my room.</p>
<h3>ARM assembly basics</h3>
<h4>Registers</h4>
<p>Registers are the closest memory to the CPU. It is a small amount of memory that is directly accessible by the CPU, thus the CPU can read and write to the registers very quickly. One register can store data of the length of one word. A word is a fixed amount of bits that can be stored in a register. The amount of bits depends on the CPU, for example, the ARM Cortex-M4 CPU uses 32-bit words, so one word is 32 bits long and therefore a register can store 32 bits.</p>
<p>Some of those registers are general purpose registers (e.g. R0-R10) and some of them are special purpose registers:</p>
<ul>
<li>R7: holds the syscall number</li>
<li>the program counter (PC): stores the address of the next instruction to be executed</li>
<li>the stack pointer (SP): stores the address of the top of the stack</li>
<li>the link register (LR): stores the address of the next instruction to be executed after a function call</li>
<li>the current program status register (CPSR): stores the status of the current program (e.g. CPU mode, interrupt mask, overflow flag, carry flag, zero flag, negative flag)</li>
<li>and more that will be described later when they are necessary</li>
</ul>
<h4>Instructions</h4>
<p>In general, an instruction in ARM is constructed as following (based on <a href="https://azeria-labs.com/arm-instruction-set-part-3/#:~:text=INTRODUCTION%20TO%20ARM%20INSTRUCTIONS">this article</a>):</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">MNEMONIC</span>{S}{condition} {Rd}<span class="token punctuation">,</span> Operand1<span class="token punctuation">,</span> Operand2
</code></pre>
<ul>
<li>MNEMONIC     - Short name (mnemonic) of the instruction (e.g. ADD, MOV, LDR, ...). It doesn't matter if the mnemonic is in upper or lower case.</li>
<li>{S}          - An optional suffix. If S is specified, the condition flags are updated on the result of the operation</li>
<li>{condition}  - Condition that is needed to be met in order for the instruction to be executed. This will be explained in the paragraph <strong>Conditional instruction execution</strong></li>
<li>{Rd}         - Register (destination) for storing the result of the instruction</li>
<li>Operand1     - First operand. Either a register or an immediate value</li>
<li>Operand2     - Second (flexible) operand. Can be an immediate value (number) or a register with an optional shift</li>
</ul>
<h5>Entry point</h5>
<p>The emulator automatically inserts the first two lines of the program automatically:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm">.global _start
_start:
</code></pre>
<p><em>_start:</em> is a label that is used to divide the code into segments. If we go to a label, we execute the code below this label. <em>.global</em> makes the start label globally accessible.</p>
<h5>Move</h5>
<p>The <em>MOV</em> instruction moves a value from the source register to the destination register.<br>
The syntax is:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">MOV</span> <span class="token operator">&lt;</span>destination register<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>source register<span class="token operator">></span> or <span class="token operator">&lt;</span>value<span class="token operator">></span>
</code></pre>
<p>A value can be a number or a label. The value is stored in the destination register. If it is a number, it must be preceded by a #. So the first instruction is:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm">.global _start
_start:
    <span class="token instruction keyword">MOV</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token operator">#</span><span class="token number">30</span>   <span class="token comment">; move the decimal value 30 to register r0 </span>
    <span class="token instruction keyword">MOV</span> <span class="token register symbol">r1</span><span class="token punctuation">,</span> <span class="token operator">#</span><span class="token number">0x1F</span> <span class="token comment">; move the hex value 0x1F (31 decimal) to register r1</span>
    <span class="token instruction keyword">MOV</span> <span class="token register symbol">r2</span><span class="token punctuation">,</span> <span class="token register symbol">r0</span>     <span class="token comment">; move the value from register r0 in register r2</span>
</code></pre>
<h5>Comments</h5>
<p>Comments are used to explain the code. They are ignored by the assembler and therefore not executed by the CPU. The syntax for comments in assembly is:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token comment">; &lt;comment></span>
</code></pre>
<p>Unfortunately, the CPUlator emulator can't handle comments in this style, so for CPUlator, the comments are written in C style (<em>//</em>):</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token operator">/</span><span class="token operator">/</span> <span class="token operator">&lt;</span>comment<span class="token operator">></span>
</code></pre>
<p>Note that this won't be recognized by any ARM assembler in the real world.</p>
<h5>End the program</h5>
<p>To end the program, we need to make a system call to let the operating system know that the program has finished. The syntax for a system call is:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">MOV</span> <span class="token register symbol">r7</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>system call number<span class="token operator">></span>  <span class="token comment">; move the system call number to the r7 register. The system call number for exit is 1.</span>
<span class="token instruction keyword">SWI</span> <span class="token operator">&lt;</span>interrupt number<span class="token operator">></span>        <span class="token comment">; make the system call by interrupting the CPU (SWI = software interrupt).</span>
</code></pre>
<p>When the OS receives the interrupt, it looks at the r7 register to see which system call was made. In this case, it is the exit system call (1), so the OS knows that the program has finished and can free the memory that was allocated for the program. In the emulator, software interrupts are not supported, but in later real-world use, this is how a program is finished.</p>
<h5>Adressing modes</h5>
<p>There are different ways to address the memory. The most common ones are:</p>
<p><strong>immediate addressing</strong>: the value is stored in the instruction itself</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">MOV</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token operator">#</span><span class="token number">30</span> <span class="token comment">; move the decimal value 30 to the r0 register</span>
</code></pre>
<p><strong>register direct addressing</strong>: the value is stored in a register</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">MOV</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token register symbol">r1</span> <span class="token comment">; move the value in the r1 register to the r0 register</span>
</code></pre>
<p><strong>register indirect addressing</strong>: the value is stored in the memory address that is stored in a register</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">LDR</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token register symbol">r1</span><span class="token punctuation">]</span> <span class="token comment">; load the value in the memory address that is stored in the r1 register to the r0 register</span>
</code></pre>
<h5>Arithmetic operations</h5>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">ADD</span> <span class="token register symbol">r2</span><span class="token punctuation">,</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token register symbol">r1</span> <span class="token comment">; add r0 and r1 and store the value in r2</span>
<span class="token instruction keyword">SUB</span> <span class="token register symbol">r2</span><span class="token punctuation">,</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token register symbol">r1</span> <span class="token comment">; r2 = r0 - r1</span>
<span class="token instruction keyword">MUL</span> <span class="token register symbol">r2</span><span class="token punctuation">,</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token register symbol">r1</span> <span class="token comment">; r2 = r0 * r1</span>
</code></pre>
<h5>CPSR register</h5>
<p>Negative numbers are stored as 2's complement, so -1 is stored as ffffff. But the computer doesn't know if <em>ffffff</em> is a representing a negative number (-1) or a huge positive number (16777215). To solve this, the CPSR register is used. Each bit in this register has a special purpose. The MSB (most significant bit) is the <em>N</em> bit. If it is set to 1, it indicates that the last operation returned a negative value. Similarly, the carry bit and the overflow bit of the CPSR are used.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
</svg>
<div class="pl-8 mr-8">
<p>To use the CPSR register, the suffix &quot;S&quot; must be appended to the mnemonic (use <em>SUBS</em> instead of <em>SUB</em>, <em>MULS</em> instead of <em>MUL</em>, ...). Else, the CPSR won't be used.</p>
</div></div>
<p>Example:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">SUBS</span> <span class="token register symbol">r2</span><span class="token punctuation">,</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token register symbol">r1</span>   <span class="token comment">; r2 = r0-r1 and the "negative" bit in CPSR ist set if r1&lt;r0.</span>
</code></pre>
<p>Another bit in CPSR is the <em>carry</em> bit that indicates if a carry took place, e.g. when the operation returns a value bigger than the register can hold. For that, a slighly different add-operation is needed:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">ADCS</span> <span class="token register symbol">r2</span><span class="token punctuation">,</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token register symbol">r1</span> <span class="token comment">; add carry: r2 = r0+r1+carry and update the cpsr register</span>
</code></pre>
<h5>Logical operations</h5>
<p><strong>AND</strong><br>
The AND operation iterates through every pair of bits A and B and returns a binary value X based on this table:</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>X</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>In ARM assembly, it works as following:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">AND</span> <span class="token register symbol">r2</span><span class="token punctuation">,</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token register symbol">r1</span> <span class="token comment">; bitwise AND between r0 and r1, stored in r2</span>
</code></pre>
<p><strong>OR</strong><br>
The OR operation iterates through every pair of bits A and B and returns a binary value X based on this table:</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>X</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>In ARM assembly, it works as following:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">ORR</span> <span class="token register symbol">r2</span><span class="token punctuation">,</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token register symbol">r1</span> <span class="token comment">; bitwise OR between r0 and r1, stored in r2 - yes, orr with thow r's is the real instruction</span>
</code></pre>
<p><strong>XOR</strong><br>
The exclusive OR (XOR) operation iterates through every pair of bits A and B and returns a binary value X based on this table:</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>X</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>In ARM assembly, it works as following:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">EOR</span> <span class="token register symbol">r2</span><span class="token punctuation">,</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token register symbol">r1</span> <span class="token comment">; bitwise XOR between r0 and r1, stored in r2 - the instruction is eor, not xor</span>
</code></pre>
<p><strong>Logical shift</strong><br>
Logical shifts are operations to shift bits of a register. The <a href="https://developer.arm.com/documentation/dui0068/b/Thumb-Instruction-Reference/Thumb-general-data-processing-instructions/ASR--LSL--LSR--and-ROR">official documentation</a> explains each one in greater detail than I do here.</p>
<ul>
<li><strong>lsl</strong>: &quot;Logical shift to left&quot; - move bits in the given register to the left. This equals a multiplication by two, but is much more efficient. The MSB gets dropped.</li>
<li><strong>lsr</strong>: &quot;Logical shift to the right&quot; - move bits in the given register to the right. This equals a division by two, but is much more efficient. The LSB gets dropped.</li>
<li><strong>ror</strong>: &quot;Rotation to right&quot; - Like the <em>lsr</em> instruction, but the LSB doesn't get dropped, it is re-appended as MSB. There is no <em>rol</em> instruction to rotate to left, but if you execute the <em>ror</em> instruction 32-n times (n being the number of rotations to left), it hs the same effect.</li>
</ul>
<p>In ARM assembly, it works as following:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">LSL</span> <span class="token register symbol">r1</span><span class="token punctuation">,</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token operator">#</span><span class="token number">1</span> <span class="token comment">; do one lsl on r0 and store the result in r1</span>
<span class="token instruction keyword">LSR</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token operator">#</span><span class="token number">5</span> <span class="token comment">; do lsr 5 times on r0 and store it back in r0</span>
<span class="token instruction keyword">ROR</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span> <span class="token operator">#</span><span class="token number">1</span> <span class="token comment">; do one ror on r0</span>
</code></pre>
<h5>Conditions</h5>
<p><strong>Branching</strong><br>
Conditions and branches are the equivalent to <em>if-else</em>-statements in higher level languages. In ARM assembly, we do a &quot;compare&quot; (CMP) instruction between two values/registers and after that, we can jump to different locations using branches.</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm">.global _start
_start:
  <span class="token comment">; fill some values in ro and r1</span>
  <span class="token instruction keyword">MOV</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span><span class="token operator">#</span><span class="token number">1</span>
  <span class="token instruction keyword">MOV</span> <span class="token register symbol">r1</span><span class="token punctuation">,</span><span class="token operator">#</span><span class="token number">2</span>

  <span class="token instruction keyword">CMP</span> <span class="token register symbol">r0</span><span class="token punctuation">,</span><span class="token register symbol">r1</span> <span class="token comment">; compare r0 and r1</span>
  <span class="token instruction keyword">BGT</span> greater <span class="token operator">/</span><span class="token operator">/</span>if CMP revealed that R0 is greater than R1 <span class="token operator">-</span><span class="token operator">></span> go to <span class="token string">"greater"</span> label
  <span class="token instruction keyword">BAL</span> default<span class="token operator">/</span><span class="token operator">/</span> branch always <span class="token punctuation">(</span>avoids stepping into <span class="token string">"greater"</span> after the execution of the last instruction<span class="token punctuation">)</span> to the <span class="token string">"defaukt"</span> label

greater:
	<span class="token instruction keyword">MOV</span> <span class="token register symbol">r2</span><span class="token punctuation">,</span> <span class="token operator">#</span><span class="token number">0xff</span>
	
default:
	<span class="token instruction keyword">MOV</span> <span class="token register symbol">r2</span><span class="token punctuation">,</span> <span class="token operator">#</span><span class="token number">0xaa</span>
</code></pre>
<p>The following branch instructions are available:</p>
<ul>
<li><strong>BGT</strong> - greater than</li>
<li><strong>BGE</strong> - greater than or equal</li>
<li><strong>BLT</strong> - less than</li>
<li><strong>BLE</strong> - less than or equal</li>
<li><strong>BEQ</strong> - equal</li>
<li><strong>BNE</strong> - not equal</li>
<li><strong>BAL</strong> - always</li>
</ul>
<p><strong>Looping</strong><br>
By using the branches, we can implement loops like <em>for</em> or <em>while</em>-loops in higher-level languages. In this example, we load a list with the values from 1-10 in the variable <em>list</em> and then we iterate through all values until we reach the end of the list:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm">.global _start
.equ endlist<span class="token punctuation">,</span> <span class="token number">0xaaaaaaaa</span> <span class="token operator">/</span><span class="token operator">/</span> memory after the list

_start:
	<span class="token instruction keyword">LDR</span> R3<span class="token punctuation">,</span><span class="token operator">=</span>endlist	<span class="token operator">/</span><span class="token operator">/</span> load the value of <span class="token string">"endlist"</span> in R3
	<span class="token instruction keyword">LDR</span> R0<span class="token punctuation">,</span><span class="token operator">=</span>list	<span class="token operator">/</span><span class="token operator">/</span> load address of list in R0
	<span class="token instruction keyword">LDR</span> R1<span class="token punctuation">,</span> <span class="token punctuation">[</span>R0<span class="token punctuation">]</span> 	<span class="token operator">/</span><span class="token operator">/</span> load the first value of the list in R1
	<span class="token instruction keyword">ADD</span> R2<span class="token punctuation">,</span> R2<span class="token punctuation">,</span> R1	<span class="token operator">/</span><span class="token operator">/</span> add R1 to R2 <span class="token punctuation">(</span>R2 <span class="token operator">=</span> R2 <span class="token operator">+</span> R1<span class="token punctuation">)</span>

loop:
	<span class="token instruction keyword">LDR</span> R1<span class="token punctuation">,</span><span class="token punctuation">[</span>R0<span class="token punctuation">,</span><span class="token operator">#</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">!</span>	<span class="token operator">/</span><span class="token operator">/</span> store the next value in list in R1
	<span class="token instruction keyword">CMP</span> R1<span class="token punctuation">,</span> R3		<span class="token operator">/</span><span class="token operator">/</span> check if this value equals the <span class="token string">"endlist"</span> value 
	<span class="token instruction keyword">BEQ</span> exit 		<span class="token operator">/</span><span class="token operator">/</span> if this is the case: go to <span class="token string">"exit"</span> label
	<span class="token instruction keyword">ADD</span> R2<span class="token punctuation">,</span>R2<span class="token punctuation">,</span> R1	<span class="token operator">/</span><span class="token operator">/</span> else: add <span class="token register symbol">r1</span> to <span class="token register symbol">r2</span>
	<span class="token instruction keyword">BAL</span> loop 		<span class="token operator">/</span><span class="token operator">/</span> goto <span class="token string">"loop"</span> 
	
exit:
	<span class="token instruction keyword">MOV</span> R4<span class="token punctuation">,</span><span class="token operator">#</span><span class="token number">0xffffffff</span>	<span class="token operator">/</span><span class="token operator">/</span>just a visual indication that we're in exit now	
	
.data
list:
	.word <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span>
	
</code></pre>
<p><strong>Conditional instruction execution</strong><br>
To make matters simpler, instead of branching, we can use conditional instructions to execute the instruction only if a condition is met. Almost every instruction in ARM assembly can be modified so that it only gets executed if a condition is met.<br>
This happens by exchanging the &quot;B&quot; in the conditional branches with the instruction, e.g. <em>BLT</em> (branch if less then) becomes <em>MOVLT</em> (move if less then) or <em>BEQ</em> (branch if equal) becomes <em>ADDEQ</em> (add if equal).<br>
Example:</p>
<pre class="language-armasm " style="counter-reset: linenumber 0"><code class="language-armasm"><span class="token instruction keyword">MOV</span> R0<span class="token punctuation">,</span><span class="token operator">#</span><span class="token number">2</span>
<span class="token instruction keyword">MOV</span> R1<span class="token punctuation">,</span><span class="token operator">#</span><span class="token number">5</span>

<span class="token instruction keyword">CMP</span> R0<span class="token punctuation">,</span>R1
<span class="token instruction keyword">ADDLT</span> R2<span class="token punctuation">,</span><span class="token operator">#</span><span class="token number">1</span>   <span class="token operator">/</span><span class="token operator">/</span> add <span class="token number">1</span> to R2 if the comparison returns that R0 is less then R1.
<span class="token instruction keyword">MOVEQ</span> R2<span class="token punctuation">,</span>R0   <span class="token operator">/</span><span class="token operator">/</span> move the value of R0 to R2 if R0<span class="token operator">=</span>R1
</code></pre>
<h5>Functions</h5>
<p>vidéo 1:34:56<br>
TODO push, pop</p>
<h2>Assembly language for x86</h2>
<p>I will not go into detail about x86 assembly language because it is not used in embedded systems and I will not use it in the future. However, I will show the key differences to ARM assembly language.</p>
<h2>TODO Debugging with gdb</h2>
<h3>TODO what is gdb?</h3>
<h3>TODO gdb commands</h3>
<h2>Useful resources</h2>
<h3>Tutorials</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=gfmRrPjnEw4">https://www.youtube.com/watch?v=gfmRrPjnEw4</a> (2:30:00 freeCodeCamp tutorial on ARM assembly)</li>
<li><a href="https://azeria-labs.com/writing-arm-assembly-part-1/">https://azeria-labs.com/writing-arm-assembly-part-1/</a> (tutorial on ARM assembly)</li>
</ul>
<h3>Tools</h3>
<ul>
<li><a href="https://cpulator.01xz.net/?sys=arm-de1soc">https://cpulator.01xz.net/?sys=arm-de1soc</a> (online ARM emulator)</li>
<li><a href="https://defuse.ca/online-x86-assembler.htm">https://defuse.ca/online-x86-assembler.htm</a> (online x86 assembler/disassembler)</li>
</ul>
<h3>Other resources</h3>
<ul>
<li>ARM Developer Suite Assembler Guide: <a href="https://developer.arm.com/documentation/dui0068/b">https://developer.arm.com/documentation/dui0068/b</a> (includes all the documentation for ARM assembly)</li>
<li>Larry Pyeatt: Modern Assembly Language Programming with the ARM Processor (<a href="https://www.amazon.com/Modern-Assembly-Language-Programming-Processor/dp/0128036982">https://www.amazon.com/Modern-Assembly-Language-Programming-Processor/dp/0128036982</a>) - great book on ARM assembly</li>
<li><a href="https://youtube.com/playlist?list=PLowKtXNTBypFbtuVMUVXNR0z1mu7dp7eH">https://youtube.com/playlist?list=PLowKtXNTBypFbtuVMUVXNR0z1mu7dp7eH</a> (Ben Eater - &quot;Build a 6502 computer from scratch&quot; (youtube series in which a computer is built from a microcontroller, every step is explained - very entertaining and educating at the same time))</li>
<li><a href="https://lioncash.github.io/ARMBook/the_apsr,_cpsr,_and_the_difference_between_them.html">https://lioncash.github.io/ARMBook/the_apsr,_cpsr,_and_the_difference_between_them.html</a></li>
</ul>


</article>

    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            do-it : option de troisième année à l'école centrale Marseille
          </p>
        </div>
      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>
