
<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <title>Le MON-2 de Léonard</title>

    <link href=/do-it/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css rel="stylesheet">
    <link href=/do-it/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css rel="stylesheet">

    <link href=/do-it/assets/stylesheets/main.css rel="stylesheet">
  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" 
  src=/do-it/assets/node_modules/mathjax/es5/tex-svg-full.js></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/do-it/">Home</a>
          <a class="mx-2" href="/do-it/about">About</a>
        </div>
      </div>
    </header>

    <main class="max-w-[1000px] mx-auto px-4">

      
<article>
  <h1  class="mb-1">Le MON-2 de Léonard</h1>
  <div class="mb-4">
    

    
      <div class=" px-4 flex items-center">
        
          <div class="font-bold">Auteur : </div>
        
        <ul class="flex not-prose list-none my-0 last:after:content-['•'] last:after:px-1 mx-0 px-1">
          
            <li class="before:content-['•'] before:px-1">Léonard Barbotteau</li>
          
        </ul>
      </div>
    
  </div>

  

  <!-- début résumé -->
<p>Python programmation orientée objet</p>
<!-- fin résumé -->
<h2>Description</h2>
<p>Dans ce MON, je vais m'intéresser aux objets dans Python. Ayant déjà une certaine aisance avec Python et aimant bien ce langage, je vais pouvoir développer mes connaissances.</p>
<h2>Développement de mes connaissances en Python</h2>
<p>Il est intéressant ans la vie de s'ouvrir à de nouvelles connaissances. Mais il est tout aussi important de les approfondir là où on les aime. Ce cours va m'y aider pour Python. Une fois n'est pas coutume, je vais réaliser ce cours à l'aide d'<a href="https://openclassrooms.com/fr/courses/7150616-apprenez-la-programmation-orientee-objet-avec-python">openclassroom</a></p>
<h1>Connaissances de base</h1>
<h2>Présentation de la classe</h2>
<p>Une <strong>classe</strong> contient d'une part un <strong>état</strong> (les variables/ données qu'elle contient) et d'autre part un <strong>comportement</strong> qui correspond à ce que la classe peut faire. Ce comportement est inclu dans les <strong>méthodes</strong> qui sont comme des fonctions associées à une classe spécifique.</p>
<p>Des <strong>objets</strong> sont donc créés en correspondance avec une classe. Le type d'un objet associé à une classe est la classe elle même.</p>
<h2>Syntaxe d'une classe</h2>
<p>Voici l'exemple de l'écriture d'une classe:</p>
<pre><code>class Epargne:
    capitalinitial = 1500
    interets = 0.05

    def calculate_income_first_month(self):
        return self.capitalinitial * self.interets
</code></pre>
<p>On peut voir au début deux variables qui lui sont associées, avec des données. Ensuite il y a une méthode qui est également associée à la classe.</p>
<h2>Construire une classe dynamique avec le constructeur __ init __</h2>
<pre><code>class Epargne:
    def __init__(self, capitalinitial, interets):
        self.capitalinitial = capitalinitial
        self.interets = interets
</code></pre>
<p>Ici on voit que les variables de la classe sont <strong>dynamiques</strong>, et on peut associer un objet à la classe épargne en remplaçant les attributs capitalinitial et interets par ce que l'on veut.</p>
<p>Dans l'exemple suivant:</p>
<pre><code>class Epargne:
    def __init__(self, capitalinitial, interets=0.05):
        self.capitalinitial = capitalinitial
        self.interets = interets
</code></pre>
<p>Les intérêts sont de base à 0.05, on peut choisir en créant un objet de changer la valeur de cet attribut ou de la garder si on ne met rien.</p>
<h2>Créer ds objets grâce aux classes</h2>
<p>Pour le premier exemple d'epargne, si on veut créer un objet on fait comme ceci:</p>
<pre><code>    epargnetest = Epargne(10000, 0.02):
</code></pre>
<p>On peut bien évidemment le modifier par la suite:</p>
<pre><code>    epargnetest.capitalinitial = 5000
</code></pre>
<p>Maintenant, regardons le premier exemple. On peut assigner le résultat de la méthode à une variable:</p>
<pre><code>income_first_month = epargne.calculate_income_first_month:
</code></pre>
<h2>Différents types d'attributs</h2>
<h3>Les attributs d'instance</h3>
<p>Il sont définis à l'aide de <strong>self</strong>. Pour y accéder on doit faire une instanciation:</p>
<pre><code>class Epargne:

    def __init__(self):
        self.interets = 0.05

    def argent(self):
        print(&quot;J'aime l'argent&quot;)
</code></pre>
<p>On doit donc faire une instanciation:</p>
<pre><code>epargnetest = Epargne()

epargnetest.interets

epargnetest.argent()
</code></pre>
<h3>Les attributs de classe</h3>
<p>Il sont définis dans le corps de la classe, et on utilise <strong>@classmethod</strong> avec un premier paramètre <strong>cls</strong></p>
<pre><code>class Epargne:

    banque = (&quot;bnp&quot;, &quot;creditagricole&quot;)

    @classmethod
    def argent(cls, monnaie):
        return(&quot;J'aime l'argent et surtout les&quot;, monnaie)
</code></pre>
<p>On peut récupérer les variables de classe sans instanciation</p>
<pre><code>Epargne.banque
print(Epargne.argent(euros))
</code></pre>
<h3>Les attributs statiques</h3>
<p>Ils n'ont quasiment pas de lien avec la classe, il faut éviter de les utiliser.</p>
<h2>Différentes fonctions utiles</h2>
<h3>Les propriétés</h3>
<p>Les <strong>setters</strong> et <strong>getters</strong> permettent de récuperer ou changer la valeur d'un attribut en gardant une cohérence pour le programmeur, donner l'information.</p>
<pre><code>class Epargne:

    def __init__(self):
        self.interets = 0.05

    def _get_interets(self):
        print &quot;Récupération des interets&quot;
        return self.interets

    def _set_interets(self, change):
        print &quot;Les interets ont changé&quot;
        self.interets  =  change

    interets=property(_get_interets, _set_interets)
</code></pre>
<p>Si interets change, on aura un message.<br>
Ce n'est pas obligatoire mais ça apporte de la clarté.</p>
<h3>La fonction dir, l'attribut __ dict __</h3>
<p>La fonction <strong>dir</strong> permet de trouver les méthodes de l'objet, l'attribut <strong>__ dict __<strong> ses attributs.</p>
<h2>L'héritage</h2>
<p>En gros, l'héritage permet de faire une <strong>sous-classe</strong> qui possède les mêmes attributs plus d'autres attributs spécifiques et d'autres méthodes, ou à l'inverse une super-classe qui en possède moins.<br>
Cette méthode permet de simplifier le code.</p>
<h3>Syntaxe de l'héritage</h3>
<pre><code>class Epargne:

    def __init__(self, interets, capitalinitial):
        self.interets = interets
        self.capitalinitial = capitalinitial
</code></pre>
<p>On peut à partir de cette classe créer une sous-classe qui va rajouter des éléments</p>
<pre><code>class SousEpargne(Epargne):
    def argent(self):
        print(&quot;J'aime l'argent&quot;)
</code></pre>
<p>On peut également remplacer les fonctions compléter les attributs:</p>
<pre><code>class SousEpargne(Epargne):
    def __init__(self, interets, capitalinitial, banque):
        self.interets = interets
        self.capitalinitial = capitalinitial
        self.banque = banque
</code></pre>
<h3>Surcharge des méthodes</h3>
<p>Lorsqu'une méthode a la même signature dans la classe <strong>enfant</strong>, elle prédomine sur la méthode de la classe <strong>parent</strong>.</p>
<p>En revanche il est possible d'accéder aux méthodes des parents depuis les classes enfants. (en utilisant la méthode super()).</p>
<h3>Classes abstraites</h3>
<p>On peut créer une classe abstraite qui ne peut être instanciée et ne peut servir que pour des sous-classes. On utilise ABC:</p>
<pre><code>from abc import ABC

class abstraite(ABC):
    def area(self):
        return 0
</code></pre>
<h3>Autres fonctionnalités de l'héritage</h3>
<ul>
<li>On peut faire des hiérarchies d'héritage</li>
<li>On peut faire un héritage multiple mais c'est assez compliqué à mettre en place</li>
</ul>
<h1>Mise en application</h1>
<p>Pour bien comprendre la programmation orientée objet, j'ai simplement fait des exercices sur internet sur un <a href="https://www.my-courses.net/2020/02/exercises-with-solutions-on-oop-object.html">site en anglais</a>, pour me familiariser avec les objets python.</p>


</article>

    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            do-it : option de troisième année à l'école centrale Marseille
          </p>
        </div>
      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>
